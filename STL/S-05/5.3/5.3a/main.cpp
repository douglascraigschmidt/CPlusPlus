#include <set>
#include <iostream>
#include <algorithm>
#include <functional>
#include <iterator>
using namespace std;

/**
 * A set is a collection of ordered data in a balanced binary tree
 * structure.
 *
 * template <typename Key,
 *           typename Compare = less<Key>,
 *           typename Allocator = allocator <Key> >
 * class set { ... };
 * 
 * Characteristics of set
 * . It orders the elements that are added to it.
 * . A set contains only one copy of any element (key) added to it.
 *
 * Elements are generated by set iterators in sequence, ordered by the
 * comparison operator provided when the set was declared (e.g.,
 * less<> or greater<>). If there was no comparison function used when
 * the set or multiset was declared, C++ uses operator < if it is
 * defined.  This works for all primitive data type elements in a set,
 * but to use a set for holding a user defined class you'll need to
 * define an operator < that compares values passed to the set when it
 * is declared.
 */
int main() {
  // Arrange the set in descending order.
  set<int, greater<>> set_of_ints({2, 1, 3, 0, 7});

  cout << set_of_ints.size() << " elements in the set" << endl;

  auto iter = set_of_ints.find (9);

  if (iter == set_of_ints.end())
    cout << "9 not found\n";
  else
    cout << "9 found\n";

  set_of_ints.insert(9);

  cout << set_of_ints.size() << " elements in the set" << endl;

  // Use generic find() algorithm.
  iter = find(set_of_ints.begin(), set_of_ints.end(), 9);

  if (iter == set_of_ints.end())
    cout << "9 not found in the set\n"  << endl;
  else
    cout << "9 found it! \n" << endl;

  // Print contents of the set in descending order.
  copy (set_of_ints.begin (),
        set_of_ints.end (),
        ostream_iterator<int> (cout, " "));

  cout << endl;

  return 0;
}

